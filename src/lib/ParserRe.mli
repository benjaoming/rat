(** Regular expressions generated by the parser.

    Regular expressions that are generated from the parser are foundamentally
    different from the regular expressions supported by the analysis, namely
    {!Re}. Parser regular expressions can contain non-regular constructs (such
    as {i backreferences} and {i lookarounds}), and it might be impossible to
    translate them into true regular expressions. For this reason, this module
    provides the functionalities to represent these regular expressions, and
    functions to translate them to {!Re.t}. *)

(** {1 Parser Regular Expressions Representation} *)

type body
(** The body of a regular expression. This is the main type of regular
    expressions. It is paired with flags to represent a regular expression. *)

type flags = string
(** Type of the flags given to a regular expressions. It is simply a string. The
    most common flags are 'g' (global), 'i' (case insensitive matching) and 'm'
    (multiline matching).*)

type t = body * flags
(** Type of regular expressions generated by {!Parser}. *)

(** {1 Constructors} *)

val eps : body
(** [eps] is the regular expression that recognizes the empty string. *)

val ch : Charset.t -> body
(** [ch cs] is the regular expression recognizing the characters in [cs]. *)

val from_char : char -> body
(** [from_char c] is the regular expression that recognizes [c]. *)

val concat : body -> body -> body
(** [concat re1 re2] is [re1 re2]. *)

val choice : body -> body -> body
(** [choice re1 re2] is [re1 | re2]. *)

val star : body -> body
(** [star re] is [re*]. *)

val plus : body -> body
(** [plus re] is [re re*]. *)

val backreference : int -> body
(** [backreference n] is [\n]. *)

val utf8 : body
(** [utf8] is the regular expression recognizing an UTF-8 character. *)

val dollar : body
(** [dollar] is the non-regular construct [$]. *)

val word_boundary : body
(** [word_boundary] is the non-regular construct [\b]. *)

val end_of_string : body
(** [end_of_string] is the non-regular construct [\Z]. *)

val any_char : body
(** [any_char] is the regular expression recognizing any character. *)

val any_digit : body
(** [any_digit] is the regular expression recognizing [{0, ..., 9}]. *)

val any_non_digit : body
(** [any_digit] is the regular expression recognizing the complement of
    [{0, ..., 9}]. *)

val any_space : body
(** [any_space] is the regular expression recognizing any space character. *)

val any_non_space : body
(** [any_non_space] is the regular expression recognizing the complement of
    [any_space]. *)

val any_word_char : body
(** [any_word_char] is the regular expression recognizing
    [{a, ..., z} ∪ {A, ...  , Z} ∪ {0, ..., 9} ∪ {_}]. *)

val any_non_word_char : body
(** [any_non_word_char] is the regular expression recognizing the complement of
    [any_word_char]. *)

val repeat : body -> int -> body
(** [repeat re n] is [re] concatenated [n] times to itself. *)

val repeat_from_until : body -> int -> int -> body
(** [repeat_from_until re from to] is [re ^ from | re ^ from+1 | ... | re ^ to].
    Fails if [from] < [to]. *)

(** {1 Conversion to Regular Expressions} *)

(** The semantics assumed for the matching. *)
type semantics = Match | Fullmatch

type conversion_error
(** Returned when it is not possible to convert {!t} to {Re.t}. *)

val report_conversion_error : Format.formatter -> conversion_error -> unit
(** [report_conversion_error fmt e] pretty-prints [e] to [fmt]. *)

val to_re : ?semantics:semantics -> t -> (Re.t, conversion_error) result
(** [to_re ~semantics re] is [re] converted from type {!t} to type {!Re.t}. If
    is not possible to convert [re], then a {!conversion_error} is returned
    instead. This can happend if [re] presents some non-regular constructs, such
    as {i backreferences} and {i lookarounds}. If [semantics] is [Match],
    appends the universal language at the end of the regular expression, to
    imitate the semantics of regex matching in programming languages such as
    Python and Java. If [semantics] is [Match] there are some edge cases in
    which the universal language is not appended at the end of the regular
    expression, such as [(a|a)*$]. In this example, the regular expression
    effectively matches only strings matched by [a*]. *)
